generator client {
  provider      = "prisma-client"
  output        = "../src/generated/prisma"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// **User Model**
// Represents a user in the system (admin, manager, or employee)
// - Belongs to ONE company
// - Can be member of MULTIPLE teams (via TeamMember)
// - Can submit survey responses
model User {
  id                       String                     @id @default(uuid())
  firstName                String
  lastName                 String
  email                    String                     @unique
  avatar                   String?
  password                 String
  role                     Role                       @default(EMPLOYEE)
  // Email verification
  verifiedAt               DateTime?
  verificationToken        String?
  verificationTokenExpires DateTime?
  // Password reset
  resetToken               String?
  resetTokenExpires        DateTime?
  createdAt                DateTime                   @default(now())
  updatedAt                DateTime                   @updatedAt
  deletedAt                DateTime?
  company                  Company                    @relation(fields: [companyId], references: [id], onDelete: Cascade)
  companyId                String
  memberships              TeamMember[]
  surveyResponses          SurveyResponse[]
  happinessSubmissions     HappinessScoreSubmission[]
}

enum Role {
  ADMIN
  EMPLOYEE
}

// **Company Model**
// Organization that owns users, teams, and surveys
// - Has MANY users
// - Has MANY teams
// - Has MANY surveys
// - Root level entity - everything belongs to a company
model Company {
  id              String           @id @default(uuid())
  name            String
  domain          String           @unique
  logo            String?
  users           User[]
  teams           Team[]
  surveys         Survey[]
  happinessScores HappinessScore[]
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  deletedAt       DateTime?
}

// **Team Model**
// Group of users within a company
// - Belongs to ONE company
// - Has MANY members (via TeamMember)
// - Can be assigned to surveys (for targeted surveys)
model Team {
  id              String           @id @default(uuid())
  name            String
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  deletedAt       DateTime?
  company         Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)
  companyId       String
  members         TeamMember[]
  surveys         SurveyTeam[]
  happinessScores HappinessScore[]
}

// **TeamMember Model**
// Junction table for User <-> Team relationship
// - Links ONE user to ONE team
// - Tracks team-specific role and membership period
// - Allows users to be in multiple teams
// - Unique constraint prevents duplicate memberships
model TeamMember {
  id       String    @id @default(uuid())
  role     Role      @default(EMPLOYEE)
  joinedAt DateTime  @default(now())
  leftAt   DateTime?
  team     Team      @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId   String
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId   String

  @@unique([teamId, userId])
}

// **Survey Model**
// Questionnaire for employee feedback
// - Belongs to ONE company
// - Has MANY questions (all RATING type)
// - Has MANY responses
// - Can be global (all teams) or targeted (specific teams)
// - Always anonymous
model Survey {
  id          String           @id @default(uuid())
  title       String
  description String?
  status      SurveyStatus     @default(DRAFT)
  isGlobal    Boolean          @default(false)
  startDate   DateTime?
  endDate     DateTime?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  deletedAt   DateTime?
  company     Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)
  companyId   String
  questions   Question[]
  responses   SurveyResponse[]
  teams       SurveyTeam[]
}

enum SurveyStatus {
  DRAFT
  ACTIVE
  CLOSED
}

// **Question Model**
// Single RATING question in a survey (always 1-5 scale)
// - Belongs to ONE survey
// - Order determines display sequence
// - Required flag determines if user must answer
model Question {
  id          String     @id @default(uuid())
  title       String // E.g., "How satisfied are you with work-life balance?"
  description String? // Optional explanation
  required    Boolean    @default(true)
  answerType  AnswerType @default(SCALE) // Type of rating scale
  order       Int // Display order (1, 2, 3...)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  survey      Survey     @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  surveyId    String
  answers     Answer[]
}

// ***AnswerType Enum**
// Types of rating scales for questions
enum AnswerType {
  SATISFACTION // "Ikke tilfreds" → "Meget tilfreds"
  AGREEMENT // "Uenig" → "Enig"
  SCALE // "1" → "5"
}

// **Answer Model**
// Single rating answer (1-5) to a question
// - Belongs to ONE response
// - Belongs to ONE question
// - Rating value is always between 1-5
// - Unique constraint: one answer per question per response
model Answer {
  id          String         @id @default(uuid())
  ratingValue Int // 1-5 scale
  createdAt   DateTime       @default(now())
  question    Question       @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId  String
  response    SurveyResponse @relation(fields: [responseId], references: [id], onDelete: Cascade)
  responseId  String

  @@unique([responseId, questionId])
}

// **SurveyResponse Model**
// A user's submission of a survey
// - Belongs to ONE survey
// - Belongs to ONE user (for personal tracking)
// - Has MANY answers (one per question)
// - TeamId tracked for aggregation but not exposed in anonymous views
// - Unique constraint: user can only submit once per survey
model SurveyResponse {
  id          String   @id @default(uuid())
  submittedAt DateTime @default(now())
  survey      Survey   @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  surveyId    String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  teamId      String? // For team aggregation (anonymous)
  answers     Answer[]

  @@unique([surveyId, userId])
  @@index([surveyId, teamId])
}

// **SurveyTeam Model**
// Junction table for Survey <-> Team relationship
// - Links surveys to specific teams (if not global)
// - Allows targeted surveys for specific teams
// - Unique constraint prevents duplicate assignments
model SurveyTeam {
  id       String @id @default(uuid())
  survey   Survey @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  surveyId String
  team     Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId   String

  @@unique([surveyId, teamId])
}

// **HappinessScoreSubmission Model**
// Tracks if a user has submitted (for hiding the card)
// - NO score stored here - only tracking
// - Used only to check if card should be visible
model HappinessScoreSubmission {
  id            String   @id @default(uuid())
  weekStartDate DateTime // Monday of the week (ISO week)
  submittedAt   DateTime @default(now())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String

  @@unique([userId, weekStartDate])
  @@index([userId])
}

// **HappinessScore Model**
// ANONYMOUS happiness scores - team level only
// - NO userId stored - completely anonymous
// - Only teamId + companyId for aggregation
// - Admin can never see who said what, even with database access
model HappinessScore {
  id            String   @id @default(uuid())
  score         Int // 1-10 (represents 0.5-5.0 in 0.5 increments)
  weekStartDate DateTime // Monday of the week (ISO week)
  submittedAt   DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  team          Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId        String
  company       Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  companyId     String

  @@index([companyId, weekStartDate])
  @@index([teamId, weekStartDate])
}
