/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `Answer` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library";
import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";

/**
 * Model Answer
 *
 */
export type AnswerModel =
  runtime.Types.Result.DefaultSelection<Prisma.$AnswerPayload>;

export type AggregateAnswer = {
  _count: AnswerCountAggregateOutputType | null;
  _min: AnswerMinAggregateOutputType | null;
  _max: AnswerMaxAggregateOutputType | null;
};

export type AnswerMinAggregateOutputType = {
  id: string | null;
  createdAt: Date | null;
  questionId: string | null;
  responseId: string | null;
};

export type AnswerMaxAggregateOutputType = {
  id: string | null;
  createdAt: Date | null;
  questionId: string | null;
  responseId: string | null;
};

export type AnswerCountAggregateOutputType = {
  id: number;
  createdAt: number;
  questionId: number;
  responseId: number;
  _all: number;
};

export type AnswerMinAggregateInputType = {
  id?: true;
  createdAt?: true;
  questionId?: true;
  responseId?: true;
};

export type AnswerMaxAggregateInputType = {
  id?: true;
  createdAt?: true;
  questionId?: true;
  responseId?: true;
};

export type AnswerCountAggregateInputType = {
  id?: true;
  createdAt?: true;
  questionId?: true;
  responseId?: true;
  _all?: true;
};

export type AnswerAggregateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which Answer to aggregate.
   */
  where?: Prisma.AnswerWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Answers to fetch.
   */
  orderBy?:
    | Prisma.AnswerOrderByWithRelationInput
    | Prisma.AnswerOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the start position
   */
  cursor?: Prisma.AnswerWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Answers from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Answers.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Count returned Answers
   **/
  _count?: true | AnswerCountAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the minimum value
   **/
  _min?: AnswerMinAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the maximum value
   **/
  _max?: AnswerMaxAggregateInputType;
};

export type GetAnswerAggregateType<T extends AnswerAggregateArgs> = {
  [P in keyof T & keyof AggregateAnswer]: P extends "_count" | "count"
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateAnswer[P]>
    : Prisma.GetScalarType<T[P], AggregateAnswer[P]>;
};

export type AnswerGroupByArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.AnswerWhereInput;
  orderBy?:
    | Prisma.AnswerOrderByWithAggregationInput
    | Prisma.AnswerOrderByWithAggregationInput[];
  by: Prisma.AnswerScalarFieldEnum[] | Prisma.AnswerScalarFieldEnum;
  having?: Prisma.AnswerScalarWhereWithAggregatesInput;
  take?: number;
  skip?: number;
  _count?: AnswerCountAggregateInputType | true;
  _min?: AnswerMinAggregateInputType;
  _max?: AnswerMaxAggregateInputType;
};

export type AnswerGroupByOutputType = {
  id: string;
  createdAt: Date;
  questionId: string;
  responseId: string;
  _count: AnswerCountAggregateOutputType | null;
  _min: AnswerMinAggregateOutputType | null;
  _max: AnswerMaxAggregateOutputType | null;
};

type GetAnswerGroupByPayload<T extends AnswerGroupByArgs> =
  Prisma.PrismaPromise<
    Array<
      Prisma.PickEnumerable<AnswerGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof AnswerGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], AnswerGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], AnswerGroupByOutputType[P]>;
      }
    >
  >;

export type AnswerWhereInput = {
  AND?: Prisma.AnswerWhereInput | Prisma.AnswerWhereInput[];
  OR?: Prisma.AnswerWhereInput[];
  NOT?: Prisma.AnswerWhereInput | Prisma.AnswerWhereInput[];
  id?: Prisma.StringFilter<"Answer"> | string;
  createdAt?: Prisma.DateTimeFilter<"Answer"> | Date | string;
  questionId?: Prisma.StringFilter<"Answer"> | string;
  responseId?: Prisma.StringFilter<"Answer"> | string;
  selectedOptions?: Prisma.QuestionOptionListRelationFilter;
  question?: Prisma.XOR<
    Prisma.QuestionScalarRelationFilter,
    Prisma.QuestionWhereInput
  >;
  response?: Prisma.XOR<
    Prisma.SurveyResponseScalarRelationFilter,
    Prisma.SurveyResponseWhereInput
  >;
};

export type AnswerOrderByWithRelationInput = {
  id?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  questionId?: Prisma.SortOrder;
  responseId?: Prisma.SortOrder;
  selectedOptions?: Prisma.QuestionOptionOrderByRelationAggregateInput;
  question?: Prisma.QuestionOrderByWithRelationInput;
  response?: Prisma.SurveyResponseOrderByWithRelationInput;
};

export type AnswerWhereUniqueInput = Prisma.AtLeast<
  {
    id?: string;
    responseId_questionId?: Prisma.AnswerResponseIdQuestionIdCompoundUniqueInput;
    AND?: Prisma.AnswerWhereInput | Prisma.AnswerWhereInput[];
    OR?: Prisma.AnswerWhereInput[];
    NOT?: Prisma.AnswerWhereInput | Prisma.AnswerWhereInput[];
    createdAt?: Prisma.DateTimeFilter<"Answer"> | Date | string;
    questionId?: Prisma.StringFilter<"Answer"> | string;
    responseId?: Prisma.StringFilter<"Answer"> | string;
    selectedOptions?: Prisma.QuestionOptionListRelationFilter;
    question?: Prisma.XOR<
      Prisma.QuestionScalarRelationFilter,
      Prisma.QuestionWhereInput
    >;
    response?: Prisma.XOR<
      Prisma.SurveyResponseScalarRelationFilter,
      Prisma.SurveyResponseWhereInput
    >;
  },
  "id" | "responseId_questionId"
>;

export type AnswerOrderByWithAggregationInput = {
  id?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  questionId?: Prisma.SortOrder;
  responseId?: Prisma.SortOrder;
  _count?: Prisma.AnswerCountOrderByAggregateInput;
  _max?: Prisma.AnswerMaxOrderByAggregateInput;
  _min?: Prisma.AnswerMinOrderByAggregateInput;
};

export type AnswerScalarWhereWithAggregatesInput = {
  AND?:
    | Prisma.AnswerScalarWhereWithAggregatesInput
    | Prisma.AnswerScalarWhereWithAggregatesInput[];
  OR?: Prisma.AnswerScalarWhereWithAggregatesInput[];
  NOT?:
    | Prisma.AnswerScalarWhereWithAggregatesInput
    | Prisma.AnswerScalarWhereWithAggregatesInput[];
  id?: Prisma.StringWithAggregatesFilter<"Answer"> | string;
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Answer"> | Date | string;
  questionId?: Prisma.StringWithAggregatesFilter<"Answer"> | string;
  responseId?: Prisma.StringWithAggregatesFilter<"Answer"> | string;
};

export type AnswerCreateInput = {
  id?: string;
  createdAt?: Date | string;
  selectedOptions?: Prisma.QuestionOptionCreateNestedManyWithoutAnswersInput;
  question: Prisma.QuestionCreateNestedOneWithoutAnswersInput;
  response: Prisma.SurveyResponseCreateNestedOneWithoutAnswersInput;
};

export type AnswerUncheckedCreateInput = {
  id?: string;
  createdAt?: Date | string;
  questionId: string;
  responseId: string;
  selectedOptions?: Prisma.QuestionOptionUncheckedCreateNestedManyWithoutAnswersInput;
};

export type AnswerUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  selectedOptions?: Prisma.QuestionOptionUpdateManyWithoutAnswersNestedInput;
  question?: Prisma.QuestionUpdateOneRequiredWithoutAnswersNestedInput;
  response?: Prisma.SurveyResponseUpdateOneRequiredWithoutAnswersNestedInput;
};

export type AnswerUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  questionId?: Prisma.StringFieldUpdateOperationsInput | string;
  responseId?: Prisma.StringFieldUpdateOperationsInput | string;
  selectedOptions?: Prisma.QuestionOptionUncheckedUpdateManyWithoutAnswersNestedInput;
};

export type AnswerCreateManyInput = {
  id?: string;
  createdAt?: Date | string;
  questionId: string;
  responseId: string;
};

export type AnswerUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type AnswerUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  questionId?: Prisma.StringFieldUpdateOperationsInput | string;
  responseId?: Prisma.StringFieldUpdateOperationsInput | string;
};

export type AnswerListRelationFilter = {
  every?: Prisma.AnswerWhereInput;
  some?: Prisma.AnswerWhereInput;
  none?: Prisma.AnswerWhereInput;
};

export type AnswerOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder;
};

export type AnswerResponseIdQuestionIdCompoundUniqueInput = {
  responseId: string;
  questionId: string;
};

export type AnswerCountOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  questionId?: Prisma.SortOrder;
  responseId?: Prisma.SortOrder;
};

export type AnswerMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  questionId?: Prisma.SortOrder;
  responseId?: Prisma.SortOrder;
};

export type AnswerMinOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  questionId?: Prisma.SortOrder;
  responseId?: Prisma.SortOrder;
};

export type AnswerCreateNestedManyWithoutQuestionInput = {
  create?:
    | Prisma.XOR<
        Prisma.AnswerCreateWithoutQuestionInput,
        Prisma.AnswerUncheckedCreateWithoutQuestionInput
      >
    | Prisma.AnswerCreateWithoutQuestionInput[]
    | Prisma.AnswerUncheckedCreateWithoutQuestionInput[];
  connectOrCreate?:
    | Prisma.AnswerCreateOrConnectWithoutQuestionInput
    | Prisma.AnswerCreateOrConnectWithoutQuestionInput[];
  createMany?: Prisma.AnswerCreateManyQuestionInputEnvelope;
  connect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
};

export type AnswerUncheckedCreateNestedManyWithoutQuestionInput = {
  create?:
    | Prisma.XOR<
        Prisma.AnswerCreateWithoutQuestionInput,
        Prisma.AnswerUncheckedCreateWithoutQuestionInput
      >
    | Prisma.AnswerCreateWithoutQuestionInput[]
    | Prisma.AnswerUncheckedCreateWithoutQuestionInput[];
  connectOrCreate?:
    | Prisma.AnswerCreateOrConnectWithoutQuestionInput
    | Prisma.AnswerCreateOrConnectWithoutQuestionInput[];
  createMany?: Prisma.AnswerCreateManyQuestionInputEnvelope;
  connect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
};

export type AnswerUpdateManyWithoutQuestionNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.AnswerCreateWithoutQuestionInput,
        Prisma.AnswerUncheckedCreateWithoutQuestionInput
      >
    | Prisma.AnswerCreateWithoutQuestionInput[]
    | Prisma.AnswerUncheckedCreateWithoutQuestionInput[];
  connectOrCreate?:
    | Prisma.AnswerCreateOrConnectWithoutQuestionInput
    | Prisma.AnswerCreateOrConnectWithoutQuestionInput[];
  upsert?:
    | Prisma.AnswerUpsertWithWhereUniqueWithoutQuestionInput
    | Prisma.AnswerUpsertWithWhereUniqueWithoutQuestionInput[];
  createMany?: Prisma.AnswerCreateManyQuestionInputEnvelope;
  set?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  disconnect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  delete?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  connect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  update?:
    | Prisma.AnswerUpdateWithWhereUniqueWithoutQuestionInput
    | Prisma.AnswerUpdateWithWhereUniqueWithoutQuestionInput[];
  updateMany?:
    | Prisma.AnswerUpdateManyWithWhereWithoutQuestionInput
    | Prisma.AnswerUpdateManyWithWhereWithoutQuestionInput[];
  deleteMany?: Prisma.AnswerScalarWhereInput | Prisma.AnswerScalarWhereInput[];
};

export type AnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.AnswerCreateWithoutQuestionInput,
        Prisma.AnswerUncheckedCreateWithoutQuestionInput
      >
    | Prisma.AnswerCreateWithoutQuestionInput[]
    | Prisma.AnswerUncheckedCreateWithoutQuestionInput[];
  connectOrCreate?:
    | Prisma.AnswerCreateOrConnectWithoutQuestionInput
    | Prisma.AnswerCreateOrConnectWithoutQuestionInput[];
  upsert?:
    | Prisma.AnswerUpsertWithWhereUniqueWithoutQuestionInput
    | Prisma.AnswerUpsertWithWhereUniqueWithoutQuestionInput[];
  createMany?: Prisma.AnswerCreateManyQuestionInputEnvelope;
  set?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  disconnect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  delete?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  connect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  update?:
    | Prisma.AnswerUpdateWithWhereUniqueWithoutQuestionInput
    | Prisma.AnswerUpdateWithWhereUniqueWithoutQuestionInput[];
  updateMany?:
    | Prisma.AnswerUpdateManyWithWhereWithoutQuestionInput
    | Prisma.AnswerUpdateManyWithWhereWithoutQuestionInput[];
  deleteMany?: Prisma.AnswerScalarWhereInput | Prisma.AnswerScalarWhereInput[];
};

export type AnswerCreateNestedManyWithoutSelectedOptionsInput = {
  create?:
    | Prisma.XOR<
        Prisma.AnswerCreateWithoutSelectedOptionsInput,
        Prisma.AnswerUncheckedCreateWithoutSelectedOptionsInput
      >
    | Prisma.AnswerCreateWithoutSelectedOptionsInput[]
    | Prisma.AnswerUncheckedCreateWithoutSelectedOptionsInput[];
  connectOrCreate?:
    | Prisma.AnswerCreateOrConnectWithoutSelectedOptionsInput
    | Prisma.AnswerCreateOrConnectWithoutSelectedOptionsInput[];
  connect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
};

export type AnswerUncheckedCreateNestedManyWithoutSelectedOptionsInput = {
  create?:
    | Prisma.XOR<
        Prisma.AnswerCreateWithoutSelectedOptionsInput,
        Prisma.AnswerUncheckedCreateWithoutSelectedOptionsInput
      >
    | Prisma.AnswerCreateWithoutSelectedOptionsInput[]
    | Prisma.AnswerUncheckedCreateWithoutSelectedOptionsInput[];
  connectOrCreate?:
    | Prisma.AnswerCreateOrConnectWithoutSelectedOptionsInput
    | Prisma.AnswerCreateOrConnectWithoutSelectedOptionsInput[];
  connect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
};

export type AnswerUpdateManyWithoutSelectedOptionsNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.AnswerCreateWithoutSelectedOptionsInput,
        Prisma.AnswerUncheckedCreateWithoutSelectedOptionsInput
      >
    | Prisma.AnswerCreateWithoutSelectedOptionsInput[]
    | Prisma.AnswerUncheckedCreateWithoutSelectedOptionsInput[];
  connectOrCreate?:
    | Prisma.AnswerCreateOrConnectWithoutSelectedOptionsInput
    | Prisma.AnswerCreateOrConnectWithoutSelectedOptionsInput[];
  upsert?:
    | Prisma.AnswerUpsertWithWhereUniqueWithoutSelectedOptionsInput
    | Prisma.AnswerUpsertWithWhereUniqueWithoutSelectedOptionsInput[];
  set?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  disconnect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  delete?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  connect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  update?:
    | Prisma.AnswerUpdateWithWhereUniqueWithoutSelectedOptionsInput
    | Prisma.AnswerUpdateWithWhereUniqueWithoutSelectedOptionsInput[];
  updateMany?:
    | Prisma.AnswerUpdateManyWithWhereWithoutSelectedOptionsInput
    | Prisma.AnswerUpdateManyWithWhereWithoutSelectedOptionsInput[];
  deleteMany?: Prisma.AnswerScalarWhereInput | Prisma.AnswerScalarWhereInput[];
};

export type AnswerUncheckedUpdateManyWithoutSelectedOptionsNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.AnswerCreateWithoutSelectedOptionsInput,
        Prisma.AnswerUncheckedCreateWithoutSelectedOptionsInput
      >
    | Prisma.AnswerCreateWithoutSelectedOptionsInput[]
    | Prisma.AnswerUncheckedCreateWithoutSelectedOptionsInput[];
  connectOrCreate?:
    | Prisma.AnswerCreateOrConnectWithoutSelectedOptionsInput
    | Prisma.AnswerCreateOrConnectWithoutSelectedOptionsInput[];
  upsert?:
    | Prisma.AnswerUpsertWithWhereUniqueWithoutSelectedOptionsInput
    | Prisma.AnswerUpsertWithWhereUniqueWithoutSelectedOptionsInput[];
  set?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  disconnect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  delete?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  connect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  update?:
    | Prisma.AnswerUpdateWithWhereUniqueWithoutSelectedOptionsInput
    | Prisma.AnswerUpdateWithWhereUniqueWithoutSelectedOptionsInput[];
  updateMany?:
    | Prisma.AnswerUpdateManyWithWhereWithoutSelectedOptionsInput
    | Prisma.AnswerUpdateManyWithWhereWithoutSelectedOptionsInput[];
  deleteMany?: Prisma.AnswerScalarWhereInput | Prisma.AnswerScalarWhereInput[];
};

export type AnswerCreateNestedManyWithoutResponseInput = {
  create?:
    | Prisma.XOR<
        Prisma.AnswerCreateWithoutResponseInput,
        Prisma.AnswerUncheckedCreateWithoutResponseInput
      >
    | Prisma.AnswerCreateWithoutResponseInput[]
    | Prisma.AnswerUncheckedCreateWithoutResponseInput[];
  connectOrCreate?:
    | Prisma.AnswerCreateOrConnectWithoutResponseInput
    | Prisma.AnswerCreateOrConnectWithoutResponseInput[];
  createMany?: Prisma.AnswerCreateManyResponseInputEnvelope;
  connect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
};

export type AnswerUncheckedCreateNestedManyWithoutResponseInput = {
  create?:
    | Prisma.XOR<
        Prisma.AnswerCreateWithoutResponseInput,
        Prisma.AnswerUncheckedCreateWithoutResponseInput
      >
    | Prisma.AnswerCreateWithoutResponseInput[]
    | Prisma.AnswerUncheckedCreateWithoutResponseInput[];
  connectOrCreate?:
    | Prisma.AnswerCreateOrConnectWithoutResponseInput
    | Prisma.AnswerCreateOrConnectWithoutResponseInput[];
  createMany?: Prisma.AnswerCreateManyResponseInputEnvelope;
  connect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
};

export type AnswerUpdateManyWithoutResponseNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.AnswerCreateWithoutResponseInput,
        Prisma.AnswerUncheckedCreateWithoutResponseInput
      >
    | Prisma.AnswerCreateWithoutResponseInput[]
    | Prisma.AnswerUncheckedCreateWithoutResponseInput[];
  connectOrCreate?:
    | Prisma.AnswerCreateOrConnectWithoutResponseInput
    | Prisma.AnswerCreateOrConnectWithoutResponseInput[];
  upsert?:
    | Prisma.AnswerUpsertWithWhereUniqueWithoutResponseInput
    | Prisma.AnswerUpsertWithWhereUniqueWithoutResponseInput[];
  createMany?: Prisma.AnswerCreateManyResponseInputEnvelope;
  set?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  disconnect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  delete?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  connect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  update?:
    | Prisma.AnswerUpdateWithWhereUniqueWithoutResponseInput
    | Prisma.AnswerUpdateWithWhereUniqueWithoutResponseInput[];
  updateMany?:
    | Prisma.AnswerUpdateManyWithWhereWithoutResponseInput
    | Prisma.AnswerUpdateManyWithWhereWithoutResponseInput[];
  deleteMany?: Prisma.AnswerScalarWhereInput | Prisma.AnswerScalarWhereInput[];
};

export type AnswerUncheckedUpdateManyWithoutResponseNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.AnswerCreateWithoutResponseInput,
        Prisma.AnswerUncheckedCreateWithoutResponseInput
      >
    | Prisma.AnswerCreateWithoutResponseInput[]
    | Prisma.AnswerUncheckedCreateWithoutResponseInput[];
  connectOrCreate?:
    | Prisma.AnswerCreateOrConnectWithoutResponseInput
    | Prisma.AnswerCreateOrConnectWithoutResponseInput[];
  upsert?:
    | Prisma.AnswerUpsertWithWhereUniqueWithoutResponseInput
    | Prisma.AnswerUpsertWithWhereUniqueWithoutResponseInput[];
  createMany?: Prisma.AnswerCreateManyResponseInputEnvelope;
  set?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  disconnect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  delete?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  connect?: Prisma.AnswerWhereUniqueInput | Prisma.AnswerWhereUniqueInput[];
  update?:
    | Prisma.AnswerUpdateWithWhereUniqueWithoutResponseInput
    | Prisma.AnswerUpdateWithWhereUniqueWithoutResponseInput[];
  updateMany?:
    | Prisma.AnswerUpdateManyWithWhereWithoutResponseInput
    | Prisma.AnswerUpdateManyWithWhereWithoutResponseInput[];
  deleteMany?: Prisma.AnswerScalarWhereInput | Prisma.AnswerScalarWhereInput[];
};

export type AnswerCreateWithoutQuestionInput = {
  id?: string;
  createdAt?: Date | string;
  selectedOptions?: Prisma.QuestionOptionCreateNestedManyWithoutAnswersInput;
  response: Prisma.SurveyResponseCreateNestedOneWithoutAnswersInput;
};

export type AnswerUncheckedCreateWithoutQuestionInput = {
  id?: string;
  createdAt?: Date | string;
  responseId: string;
  selectedOptions?: Prisma.QuestionOptionUncheckedCreateNestedManyWithoutAnswersInput;
};

export type AnswerCreateOrConnectWithoutQuestionInput = {
  where: Prisma.AnswerWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.AnswerCreateWithoutQuestionInput,
    Prisma.AnswerUncheckedCreateWithoutQuestionInput
  >;
};

export type AnswerCreateManyQuestionInputEnvelope = {
  data:
    | Prisma.AnswerCreateManyQuestionInput
    | Prisma.AnswerCreateManyQuestionInput[];
  skipDuplicates?: boolean;
};

export type AnswerUpsertWithWhereUniqueWithoutQuestionInput = {
  where: Prisma.AnswerWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.AnswerUpdateWithoutQuestionInput,
    Prisma.AnswerUncheckedUpdateWithoutQuestionInput
  >;
  create: Prisma.XOR<
    Prisma.AnswerCreateWithoutQuestionInput,
    Prisma.AnswerUncheckedCreateWithoutQuestionInput
  >;
};

export type AnswerUpdateWithWhereUniqueWithoutQuestionInput = {
  where: Prisma.AnswerWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.AnswerUpdateWithoutQuestionInput,
    Prisma.AnswerUncheckedUpdateWithoutQuestionInput
  >;
};

export type AnswerUpdateManyWithWhereWithoutQuestionInput = {
  where: Prisma.AnswerScalarWhereInput;
  data: Prisma.XOR<
    Prisma.AnswerUpdateManyMutationInput,
    Prisma.AnswerUncheckedUpdateManyWithoutQuestionInput
  >;
};

export type AnswerScalarWhereInput = {
  AND?: Prisma.AnswerScalarWhereInput | Prisma.AnswerScalarWhereInput[];
  OR?: Prisma.AnswerScalarWhereInput[];
  NOT?: Prisma.AnswerScalarWhereInput | Prisma.AnswerScalarWhereInput[];
  id?: Prisma.StringFilter<"Answer"> | string;
  createdAt?: Prisma.DateTimeFilter<"Answer"> | Date | string;
  questionId?: Prisma.StringFilter<"Answer"> | string;
  responseId?: Prisma.StringFilter<"Answer"> | string;
};

export type AnswerCreateWithoutSelectedOptionsInput = {
  id?: string;
  createdAt?: Date | string;
  question: Prisma.QuestionCreateNestedOneWithoutAnswersInput;
  response: Prisma.SurveyResponseCreateNestedOneWithoutAnswersInput;
};

export type AnswerUncheckedCreateWithoutSelectedOptionsInput = {
  id?: string;
  createdAt?: Date | string;
  questionId: string;
  responseId: string;
};

export type AnswerCreateOrConnectWithoutSelectedOptionsInput = {
  where: Prisma.AnswerWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.AnswerCreateWithoutSelectedOptionsInput,
    Prisma.AnswerUncheckedCreateWithoutSelectedOptionsInput
  >;
};

export type AnswerUpsertWithWhereUniqueWithoutSelectedOptionsInput = {
  where: Prisma.AnswerWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.AnswerUpdateWithoutSelectedOptionsInput,
    Prisma.AnswerUncheckedUpdateWithoutSelectedOptionsInput
  >;
  create: Prisma.XOR<
    Prisma.AnswerCreateWithoutSelectedOptionsInput,
    Prisma.AnswerUncheckedCreateWithoutSelectedOptionsInput
  >;
};

export type AnswerUpdateWithWhereUniqueWithoutSelectedOptionsInput = {
  where: Prisma.AnswerWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.AnswerUpdateWithoutSelectedOptionsInput,
    Prisma.AnswerUncheckedUpdateWithoutSelectedOptionsInput
  >;
};

export type AnswerUpdateManyWithWhereWithoutSelectedOptionsInput = {
  where: Prisma.AnswerScalarWhereInput;
  data: Prisma.XOR<
    Prisma.AnswerUpdateManyMutationInput,
    Prisma.AnswerUncheckedUpdateManyWithoutSelectedOptionsInput
  >;
};

export type AnswerCreateWithoutResponseInput = {
  id?: string;
  createdAt?: Date | string;
  selectedOptions?: Prisma.QuestionOptionCreateNestedManyWithoutAnswersInput;
  question: Prisma.QuestionCreateNestedOneWithoutAnswersInput;
};

export type AnswerUncheckedCreateWithoutResponseInput = {
  id?: string;
  createdAt?: Date | string;
  questionId: string;
  selectedOptions?: Prisma.QuestionOptionUncheckedCreateNestedManyWithoutAnswersInput;
};

export type AnswerCreateOrConnectWithoutResponseInput = {
  where: Prisma.AnswerWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.AnswerCreateWithoutResponseInput,
    Prisma.AnswerUncheckedCreateWithoutResponseInput
  >;
};

export type AnswerCreateManyResponseInputEnvelope = {
  data:
    | Prisma.AnswerCreateManyResponseInput
    | Prisma.AnswerCreateManyResponseInput[];
  skipDuplicates?: boolean;
};

export type AnswerUpsertWithWhereUniqueWithoutResponseInput = {
  where: Prisma.AnswerWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.AnswerUpdateWithoutResponseInput,
    Prisma.AnswerUncheckedUpdateWithoutResponseInput
  >;
  create: Prisma.XOR<
    Prisma.AnswerCreateWithoutResponseInput,
    Prisma.AnswerUncheckedCreateWithoutResponseInput
  >;
};

export type AnswerUpdateWithWhereUniqueWithoutResponseInput = {
  where: Prisma.AnswerWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.AnswerUpdateWithoutResponseInput,
    Prisma.AnswerUncheckedUpdateWithoutResponseInput
  >;
};

export type AnswerUpdateManyWithWhereWithoutResponseInput = {
  where: Prisma.AnswerScalarWhereInput;
  data: Prisma.XOR<
    Prisma.AnswerUpdateManyMutationInput,
    Prisma.AnswerUncheckedUpdateManyWithoutResponseInput
  >;
};

export type AnswerCreateManyQuestionInput = {
  id?: string;
  createdAt?: Date | string;
  responseId: string;
};

export type AnswerUpdateWithoutQuestionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  selectedOptions?: Prisma.QuestionOptionUpdateManyWithoutAnswersNestedInput;
  response?: Prisma.SurveyResponseUpdateOneRequiredWithoutAnswersNestedInput;
};

export type AnswerUncheckedUpdateWithoutQuestionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  responseId?: Prisma.StringFieldUpdateOperationsInput | string;
  selectedOptions?: Prisma.QuestionOptionUncheckedUpdateManyWithoutAnswersNestedInput;
};

export type AnswerUncheckedUpdateManyWithoutQuestionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  responseId?: Prisma.StringFieldUpdateOperationsInput | string;
};

export type AnswerUpdateWithoutSelectedOptionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  question?: Prisma.QuestionUpdateOneRequiredWithoutAnswersNestedInput;
  response?: Prisma.SurveyResponseUpdateOneRequiredWithoutAnswersNestedInput;
};

export type AnswerUncheckedUpdateWithoutSelectedOptionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  questionId?: Prisma.StringFieldUpdateOperationsInput | string;
  responseId?: Prisma.StringFieldUpdateOperationsInput | string;
};

export type AnswerUncheckedUpdateManyWithoutSelectedOptionsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  questionId?: Prisma.StringFieldUpdateOperationsInput | string;
  responseId?: Prisma.StringFieldUpdateOperationsInput | string;
};

export type AnswerCreateManyResponseInput = {
  id?: string;
  createdAt?: Date | string;
  questionId: string;
};

export type AnswerUpdateWithoutResponseInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  selectedOptions?: Prisma.QuestionOptionUpdateManyWithoutAnswersNestedInput;
  question?: Prisma.QuestionUpdateOneRequiredWithoutAnswersNestedInput;
};

export type AnswerUncheckedUpdateWithoutResponseInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  questionId?: Prisma.StringFieldUpdateOperationsInput | string;
  selectedOptions?: Prisma.QuestionOptionUncheckedUpdateManyWithoutAnswersNestedInput;
};

export type AnswerUncheckedUpdateManyWithoutResponseInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  questionId?: Prisma.StringFieldUpdateOperationsInput | string;
};

/**
 * Count Type AnswerCountOutputType
 */

export type AnswerCountOutputType = {
  selectedOptions: number;
};

export type AnswerCountOutputTypeSelect<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  selectedOptions?: boolean | AnswerCountOutputTypeCountSelectedOptionsArgs;
};

/**
 * AnswerCountOutputType without action
 */
export type AnswerCountOutputTypeDefaultArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the AnswerCountOutputType
   */
  select?: Prisma.AnswerCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * AnswerCountOutputType without action
 */
export type AnswerCountOutputTypeCountSelectedOptionsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.QuestionOptionWhereInput;
};

export type AnswerSelect<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    createdAt?: boolean;
    questionId?: boolean;
    responseId?: boolean;
    selectedOptions?: boolean | Prisma.Answer$selectedOptionsArgs<ExtArgs>;
    question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>;
    response?: boolean | Prisma.SurveyResponseDefaultArgs<ExtArgs>;
    _count?: boolean | Prisma.AnswerCountOutputTypeDefaultArgs<ExtArgs>;
  },
  ExtArgs["result"]["answer"]
>;

export type AnswerSelectCreateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    createdAt?: boolean;
    questionId?: boolean;
    responseId?: boolean;
    question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>;
    response?: boolean | Prisma.SurveyResponseDefaultArgs<ExtArgs>;
  },
  ExtArgs["result"]["answer"]
>;

export type AnswerSelectUpdateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    createdAt?: boolean;
    questionId?: boolean;
    responseId?: boolean;
    question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>;
    response?: boolean | Prisma.SurveyResponseDefaultArgs<ExtArgs>;
  },
  ExtArgs["result"]["answer"]
>;

export type AnswerSelectScalar = {
  id?: boolean;
  createdAt?: boolean;
  questionId?: boolean;
  responseId?: boolean;
};

export type AnswerOmit<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
  "id" | "createdAt" | "questionId" | "responseId",
  ExtArgs["result"]["answer"]
>;
export type AnswerInclude<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  selectedOptions?: boolean | Prisma.Answer$selectedOptionsArgs<ExtArgs>;
  question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>;
  response?: boolean | Prisma.SurveyResponseDefaultArgs<ExtArgs>;
  _count?: boolean | Prisma.AnswerCountOutputTypeDefaultArgs<ExtArgs>;
};
export type AnswerIncludeCreateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>;
  response?: boolean | Prisma.SurveyResponseDefaultArgs<ExtArgs>;
};
export type AnswerIncludeUpdateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>;
  response?: boolean | Prisma.SurveyResponseDefaultArgs<ExtArgs>;
};

export type $AnswerPayload<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  name: "Answer";
  objects: {
    selectedOptions: Prisma.$QuestionOptionPayload<ExtArgs>[];
    question: Prisma.$QuestionPayload<ExtArgs>;
    response: Prisma.$SurveyResponsePayload<ExtArgs>;
  };
  scalars: runtime.Types.Extensions.GetPayloadResult<
    {
      id: string;
      createdAt: Date;
      questionId: string;
      responseId: string;
    },
    ExtArgs["result"]["answer"]
  >;
  composites: {};
};

export type AnswerGetPayload<
  S extends boolean | null | undefined | AnswerDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$AnswerPayload, S>;

export type AnswerCountArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = Omit<AnswerFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
  select?: AnswerCountAggregateInputType | true;
};

export interface AnswerDelegate<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> {
  [K: symbol]: {
    types: Prisma.TypeMap<ExtArgs>["model"]["Answer"];
    meta: { name: "Answer" };
  };
  /**
   * Find zero or one Answer that matches the filter.
   * @param {AnswerFindUniqueArgs} args - Arguments to find a Answer
   * @example
   * // Get one Answer
   * const answer = await prisma.answer.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends AnswerFindUniqueArgs>(
    args: Prisma.SelectSubset<T, AnswerFindUniqueArgs<ExtArgs>>
  ): Prisma.Prisma__AnswerClient<
    runtime.Types.Result.GetResult<
      Prisma.$AnswerPayload<ExtArgs>,
      T,
      "findUnique",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find one Answer that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {AnswerFindUniqueOrThrowArgs} args - Arguments to find a Answer
   * @example
   * // Get one Answer
   * const answer = await prisma.answer.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends AnswerFindUniqueOrThrowArgs>(
    args: Prisma.SelectSubset<T, AnswerFindUniqueOrThrowArgs<ExtArgs>>
  ): Prisma.Prisma__AnswerClient<
    runtime.Types.Result.GetResult<
      Prisma.$AnswerPayload<ExtArgs>,
      T,
      "findUniqueOrThrow",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first Answer that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AnswerFindFirstArgs} args - Arguments to find a Answer
   * @example
   * // Get one Answer
   * const answer = await prisma.answer.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends AnswerFindFirstArgs>(
    args?: Prisma.SelectSubset<T, AnswerFindFirstArgs<ExtArgs>>
  ): Prisma.Prisma__AnswerClient<
    runtime.Types.Result.GetResult<
      Prisma.$AnswerPayload<ExtArgs>,
      T,
      "findFirst",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first Answer that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AnswerFindFirstOrThrowArgs} args - Arguments to find a Answer
   * @example
   * // Get one Answer
   * const answer = await prisma.answer.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends AnswerFindFirstOrThrowArgs>(
    args?: Prisma.SelectSubset<T, AnswerFindFirstOrThrowArgs<ExtArgs>>
  ): Prisma.Prisma__AnswerClient<
    runtime.Types.Result.GetResult<
      Prisma.$AnswerPayload<ExtArgs>,
      T,
      "findFirstOrThrow",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find zero or more Answers that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AnswerFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Answers
   * const answers = await prisma.answer.findMany()
   *
   * // Get first 10 Answers
   * const answers = await prisma.answer.findMany({ take: 10 })
   *
   * // Only select the `id`
   * const answerWithIdOnly = await prisma.answer.findMany({ select: { id: true } })
   *
   */
  findMany<T extends AnswerFindManyArgs>(
    args?: Prisma.SelectSubset<T, AnswerFindManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$AnswerPayload<ExtArgs>,
      T,
      "findMany",
      GlobalOmitOptions
    >
  >;

  /**
   * Create a Answer.
   * @param {AnswerCreateArgs} args - Arguments to create a Answer.
   * @example
   * // Create one Answer
   * const Answer = await prisma.answer.create({
   *   data: {
   *     // ... data to create a Answer
   *   }
   * })
   *
   */
  create<T extends AnswerCreateArgs>(
    args: Prisma.SelectSubset<T, AnswerCreateArgs<ExtArgs>>
  ): Prisma.Prisma__AnswerClient<
    runtime.Types.Result.GetResult<
      Prisma.$AnswerPayload<ExtArgs>,
      T,
      "create",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Create many Answers.
   * @param {AnswerCreateManyArgs} args - Arguments to create many Answers.
   * @example
   * // Create many Answers
   * const answer = await prisma.answer.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   */
  createMany<T extends AnswerCreateManyArgs>(
    args?: Prisma.SelectSubset<T, AnswerCreateManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Create many Answers and returns the data saved in the database.
   * @param {AnswerCreateManyAndReturnArgs} args - Arguments to create many Answers.
   * @example
   * // Create many Answers
   * const answer = await prisma.answer.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Create many Answers and only return the `id`
   * const answerWithIdOnly = await prisma.answer.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  createManyAndReturn<T extends AnswerCreateManyAndReturnArgs>(
    args?: Prisma.SelectSubset<T, AnswerCreateManyAndReturnArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$AnswerPayload<ExtArgs>,
      T,
      "createManyAndReturn",
      GlobalOmitOptions
    >
  >;

  /**
   * Delete a Answer.
   * @param {AnswerDeleteArgs} args - Arguments to delete one Answer.
   * @example
   * // Delete one Answer
   * const Answer = await prisma.answer.delete({
   *   where: {
   *     // ... filter to delete one Answer
   *   }
   * })
   *
   */
  delete<T extends AnswerDeleteArgs>(
    args: Prisma.SelectSubset<T, AnswerDeleteArgs<ExtArgs>>
  ): Prisma.Prisma__AnswerClient<
    runtime.Types.Result.GetResult<
      Prisma.$AnswerPayload<ExtArgs>,
      T,
      "delete",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Update one Answer.
   * @param {AnswerUpdateArgs} args - Arguments to update one Answer.
   * @example
   * // Update one Answer
   * const answer = await prisma.answer.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  update<T extends AnswerUpdateArgs>(
    args: Prisma.SelectSubset<T, AnswerUpdateArgs<ExtArgs>>
  ): Prisma.Prisma__AnswerClient<
    runtime.Types.Result.GetResult<
      Prisma.$AnswerPayload<ExtArgs>,
      T,
      "update",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Delete zero or more Answers.
   * @param {AnswerDeleteManyArgs} args - Arguments to filter Answers to delete.
   * @example
   * // Delete a few Answers
   * const { count } = await prisma.answer.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   *
   */
  deleteMany<T extends AnswerDeleteManyArgs>(
    args?: Prisma.SelectSubset<T, AnswerDeleteManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more Answers.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AnswerUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Answers
   * const answer = await prisma.answer.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  updateMany<T extends AnswerUpdateManyArgs>(
    args: Prisma.SelectSubset<T, AnswerUpdateManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more Answers and returns the data updated in the database.
   * @param {AnswerUpdateManyAndReturnArgs} args - Arguments to update many Answers.
   * @example
   * // Update many Answers
   * const answer = await prisma.answer.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Update zero or more Answers and only return the `id`
   * const answerWithIdOnly = await prisma.answer.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  updateManyAndReturn<T extends AnswerUpdateManyAndReturnArgs>(
    args: Prisma.SelectSubset<T, AnswerUpdateManyAndReturnArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$AnswerPayload<ExtArgs>,
      T,
      "updateManyAndReturn",
      GlobalOmitOptions
    >
  >;

  /**
   * Create or update one Answer.
   * @param {AnswerUpsertArgs} args - Arguments to update or create a Answer.
   * @example
   * // Update or create a Answer
   * const answer = await prisma.answer.upsert({
   *   create: {
   *     // ... data to create a Answer
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Answer we want to update
   *   }
   * })
   */
  upsert<T extends AnswerUpsertArgs>(
    args: Prisma.SelectSubset<T, AnswerUpsertArgs<ExtArgs>>
  ): Prisma.Prisma__AnswerClient<
    runtime.Types.Result.GetResult<
      Prisma.$AnswerPayload<ExtArgs>,
      T,
      "upsert",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Count the number of Answers.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AnswerCountArgs} args - Arguments to filter Answers to count.
   * @example
   * // Count the number of Answers
   * const count = await prisma.answer.count({
   *   where: {
   *     // ... the filter for the Answers we want to count
   *   }
   * })
   **/
  count<T extends AnswerCountArgs>(
    args?: Prisma.Subset<T, AnswerCountArgs>
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<"select", any>
      ? T["select"] extends true
        ? number
        : Prisma.GetScalarType<T["select"], AnswerCountAggregateOutputType>
      : number
  >;

  /**
   * Allows you to perform aggregations operations on a Answer.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
   **/
  aggregate<T extends AnswerAggregateArgs>(
    args: Prisma.Subset<T, AnswerAggregateArgs>
  ): Prisma.PrismaPromise<GetAnswerAggregateType<T>>;

  /**
   * Group by Answer.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {AnswerGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   *
   **/
  groupBy<
    T extends AnswerGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<"skip", Prisma.Keys<T>>,
      Prisma.Extends<"take", Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: AnswerGroupByArgs["orderBy"] }
      : { orderBy?: AnswerGroupByArgs["orderBy"] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<
      Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
    >,
    ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T["having"]>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
      ? `Error: "by" must not be empty.`
      : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
                ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                : [
                    Error,
                    "Field ",
                    P,
                    ` in "having" needs to be provided in "by"`,
                  ];
          }[HavingFields]
        : "take" extends Prisma.Keys<T>
          ? "orderBy" extends Prisma.Keys<T>
            ? ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields]
            : 'Error: If you provide "take", you also need to provide "orderBy"'
          : "skip" extends Prisma.Keys<T>
            ? "orderBy" extends Prisma.Keys<T>
              ? ByValid extends Prisma.True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "skip", you also need to provide "orderBy"'
            : ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields],
  >(
    args: Prisma.SubsetIntersection<T, AnswerGroupByArgs, OrderByArg> &
      InputErrors
  ): {} extends InputErrors
    ? GetAnswerGroupByPayload<T>
    : Prisma.PrismaPromise<InputErrors>;
  /**
   * Fields of the Answer model
   */
  readonly fields: AnswerFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Answer.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__AnswerClient<
  T,
  Null = never,
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise";
  selectedOptions<T extends Prisma.Answer$selectedOptionsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Answer$selectedOptionsArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$QuestionOptionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  question<T extends Prisma.QuestionDefaultArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.QuestionDefaultArgs<ExtArgs>>
  ): Prisma.Prisma__QuestionClient<
    | runtime.Types.Result.GetResult<
        Prisma.$QuestionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >
    | Null,
    Null,
    ExtArgs,
    GlobalOmitOptions
  >;
  response<T extends Prisma.SurveyResponseDefaultArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.SurveyResponseDefaultArgs<ExtArgs>>
  ): Prisma.Prisma__SurveyResponseClient<
    | runtime.Types.Result.GetResult<
        Prisma.$SurveyResponsePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >
    | Null,
    Null,
    ExtArgs,
    GlobalOmitOptions
  >;
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(
    onfulfilled?:
      | ((value: T) => TResult1 | PromiseLike<TResult1>)
      | undefined
      | null,
    onrejected?:
      | ((reason: any) => TResult2 | PromiseLike<TResult2>)
      | undefined
      | null
  ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(
    onrejected?:
      | ((reason: any) => TResult | PromiseLike<TResult>)
      | undefined
      | null
  ): runtime.Types.Utils.JsPromise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(
    onfinally?: (() => void) | undefined | null
  ): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the Answer model
 */
export interface AnswerFieldRefs {
  readonly id: Prisma.FieldRef<"Answer", "String">;
  readonly createdAt: Prisma.FieldRef<"Answer", "DateTime">;
  readonly questionId: Prisma.FieldRef<"Answer", "String">;
  readonly responseId: Prisma.FieldRef<"Answer", "String">;
}

// Custom InputTypes
/**
 * Answer findUnique
 */
export type AnswerFindUniqueArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Answer
   */
  select?: Prisma.AnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Answer
   */
  omit?: Prisma.AnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AnswerInclude<ExtArgs> | null;
  /**
   * Filter, which Answer to fetch.
   */
  where: Prisma.AnswerWhereUniqueInput;
};

/**
 * Answer findUniqueOrThrow
 */
export type AnswerFindUniqueOrThrowArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Answer
   */
  select?: Prisma.AnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Answer
   */
  omit?: Prisma.AnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AnswerInclude<ExtArgs> | null;
  /**
   * Filter, which Answer to fetch.
   */
  where: Prisma.AnswerWhereUniqueInput;
};

/**
 * Answer findFirst
 */
export type AnswerFindFirstArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Answer
   */
  select?: Prisma.AnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Answer
   */
  omit?: Prisma.AnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AnswerInclude<ExtArgs> | null;
  /**
   * Filter, which Answer to fetch.
   */
  where?: Prisma.AnswerWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Answers to fetch.
   */
  orderBy?:
    | Prisma.AnswerOrderByWithRelationInput
    | Prisma.AnswerOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for Answers.
   */
  cursor?: Prisma.AnswerWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Answers from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Answers.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of Answers.
   */
  distinct?: Prisma.AnswerScalarFieldEnum | Prisma.AnswerScalarFieldEnum[];
};

/**
 * Answer findFirstOrThrow
 */
export type AnswerFindFirstOrThrowArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Answer
   */
  select?: Prisma.AnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Answer
   */
  omit?: Prisma.AnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AnswerInclude<ExtArgs> | null;
  /**
   * Filter, which Answer to fetch.
   */
  where?: Prisma.AnswerWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Answers to fetch.
   */
  orderBy?:
    | Prisma.AnswerOrderByWithRelationInput
    | Prisma.AnswerOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for Answers.
   */
  cursor?: Prisma.AnswerWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Answers from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Answers.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of Answers.
   */
  distinct?: Prisma.AnswerScalarFieldEnum | Prisma.AnswerScalarFieldEnum[];
};

/**
 * Answer findMany
 */
export type AnswerFindManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Answer
   */
  select?: Prisma.AnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Answer
   */
  omit?: Prisma.AnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AnswerInclude<ExtArgs> | null;
  /**
   * Filter, which Answers to fetch.
   */
  where?: Prisma.AnswerWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Answers to fetch.
   */
  orderBy?:
    | Prisma.AnswerOrderByWithRelationInput
    | Prisma.AnswerOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for listing Answers.
   */
  cursor?: Prisma.AnswerWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Answers from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Answers.
   */
  skip?: number;
  distinct?: Prisma.AnswerScalarFieldEnum | Prisma.AnswerScalarFieldEnum[];
};

/**
 * Answer create
 */
export type AnswerCreateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Answer
   */
  select?: Prisma.AnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Answer
   */
  omit?: Prisma.AnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AnswerInclude<ExtArgs> | null;
  /**
   * The data needed to create a Answer.
   */
  data: Prisma.XOR<Prisma.AnswerCreateInput, Prisma.AnswerUncheckedCreateInput>;
};

/**
 * Answer createMany
 */
export type AnswerCreateManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to create many Answers.
   */
  data: Prisma.AnswerCreateManyInput | Prisma.AnswerCreateManyInput[];
  skipDuplicates?: boolean;
};

/**
 * Answer createManyAndReturn
 */
export type AnswerCreateManyAndReturnArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Answer
   */
  select?: Prisma.AnswerSelectCreateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the Answer
   */
  omit?: Prisma.AnswerOmit<ExtArgs> | null;
  /**
   * The data used to create many Answers.
   */
  data: Prisma.AnswerCreateManyInput | Prisma.AnswerCreateManyInput[];
  skipDuplicates?: boolean;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AnswerIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * Answer update
 */
export type AnswerUpdateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Answer
   */
  select?: Prisma.AnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Answer
   */
  omit?: Prisma.AnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AnswerInclude<ExtArgs> | null;
  /**
   * The data needed to update a Answer.
   */
  data: Prisma.XOR<Prisma.AnswerUpdateInput, Prisma.AnswerUncheckedUpdateInput>;
  /**
   * Choose, which Answer to update.
   */
  where: Prisma.AnswerWhereUniqueInput;
};

/**
 * Answer updateMany
 */
export type AnswerUpdateManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to update Answers.
   */
  data: Prisma.XOR<
    Prisma.AnswerUpdateManyMutationInput,
    Prisma.AnswerUncheckedUpdateManyInput
  >;
  /**
   * Filter which Answers to update
   */
  where?: Prisma.AnswerWhereInput;
  /**
   * Limit how many Answers to update.
   */
  limit?: number;
};

/**
 * Answer updateManyAndReturn
 */
export type AnswerUpdateManyAndReturnArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Answer
   */
  select?: Prisma.AnswerSelectUpdateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the Answer
   */
  omit?: Prisma.AnswerOmit<ExtArgs> | null;
  /**
   * The data used to update Answers.
   */
  data: Prisma.XOR<
    Prisma.AnswerUpdateManyMutationInput,
    Prisma.AnswerUncheckedUpdateManyInput
  >;
  /**
   * Filter which Answers to update
   */
  where?: Prisma.AnswerWhereInput;
  /**
   * Limit how many Answers to update.
   */
  limit?: number;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AnswerIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * Answer upsert
 */
export type AnswerUpsertArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Answer
   */
  select?: Prisma.AnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Answer
   */
  omit?: Prisma.AnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AnswerInclude<ExtArgs> | null;
  /**
   * The filter to search for the Answer to update in case it exists.
   */
  where: Prisma.AnswerWhereUniqueInput;
  /**
   * In case the Answer found by the `where` argument doesn't exist, create a new Answer with this data.
   */
  create: Prisma.XOR<
    Prisma.AnswerCreateInput,
    Prisma.AnswerUncheckedCreateInput
  >;
  /**
   * In case the Answer was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<
    Prisma.AnswerUpdateInput,
    Prisma.AnswerUncheckedUpdateInput
  >;
};

/**
 * Answer delete
 */
export type AnswerDeleteArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Answer
   */
  select?: Prisma.AnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Answer
   */
  omit?: Prisma.AnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AnswerInclude<ExtArgs> | null;
  /**
   * Filter which Answer to delete.
   */
  where: Prisma.AnswerWhereUniqueInput;
};

/**
 * Answer deleteMany
 */
export type AnswerDeleteManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which Answers to delete
   */
  where?: Prisma.AnswerWhereInput;
  /**
   * Limit how many Answers to delete.
   */
  limit?: number;
};

/**
 * Answer.selectedOptions
 */
export type Answer$selectedOptionsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the QuestionOption
   */
  select?: Prisma.QuestionOptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the QuestionOption
   */
  omit?: Prisma.QuestionOptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QuestionOptionInclude<ExtArgs> | null;
  where?: Prisma.QuestionOptionWhereInput;
  orderBy?:
    | Prisma.QuestionOptionOrderByWithRelationInput
    | Prisma.QuestionOptionOrderByWithRelationInput[];
  cursor?: Prisma.QuestionOptionWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.QuestionOptionScalarFieldEnum
    | Prisma.QuestionOptionScalarFieldEnum[];
};

/**
 * Answer without action
 */
export type AnswerDefaultArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Answer
   */
  select?: Prisma.AnswerSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Answer
   */
  omit?: Prisma.AnswerOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.AnswerInclude<ExtArgs> | null;
};
